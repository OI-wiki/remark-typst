'use strict'

import { visit } from 'unist-util-visit'
import { extname, join, dirname, basename } from 'path'
import { execFileSync, spawnSync } from 'child_process'
import { existsSync, writeFileSync, copyFileSync } from 'fs'
import request from 'sync-request'
import { URL } from 'url'

// Utilities
import { all, isInternalLink, toPrefix, joinRelative, isUrl, trailingLineFeed, 
  forceLinebreak, escapeAsString, getLanguage, capitalize, removeQuotes } from './util.js'
// Escape reserved symbols
import escape from '../escape-typst/src/index.js'
// MathJax SVG export
import { renderSvg } from '../remark-mathjax/svg.js'

// 给 String 添加 format 方法，方便格式化输出
if (!String.prototype.format) {
  String.prototype.format = function () {
    const args = arguments
    return this.replace(/{(\d+)}/g, (match, number) => {
      return typeof args[number] !== 'undefined' ? args[number] : match
    })
  }
}

const DETAILS_TYPES = [
  'note', 'abstract', 'info', 'tip', 'success', 'question',
  'warning', 'failure', 'danger', 'bug', 'example', 'quote',
]

export default toTypst

function toTypst(tree, options) {
  // Value: Node
  const mapFootnoteDefinitions = new Map()
  // Value: Node
  const mapDefinitions = new Map()
  // Value: { location: string, children: content }
  const arrayLinks = new Array()

  // Index of current foreign link
  let linkIndex = 0
  // Whether footnotes are used, which suggests that a section
  // named "References" is present in original markdown document
  let hasFootnotes = false
  // Whether the current details block should be unwrapped
  let unwrap = false
  // Whether the current paragraph should be indented
  let firstPar = true
  // Whether the current text node should be escaped as a string
  let isEscapingAsString = false
  
  // 处理掉所有标签定义和链接跳转定义
  parseDefinition(tree)
  // 解析文章
  let article = `// Generated by remark-typst
#import "@preview/tablex:0.0.5": *
#import "../oi-wiki.typ": *
`
  article += parse(tree)
  // 创建文章尾注，对外链添加二维码
  if (linkIndex > 0) {
    if (hasFootnotes === false) {
      article += '#heading(level: {0}, numbering: none, outlined: false)[参考资料与注释]\n'.format(
        options.depth + 1)
    }

    article += '#links-grid('
    for (const [i, link] of arrayLinks.entries()) {
      article += 'links-cell[#text(fill: cmyk(0%, 100%, 100%, 0%))[\\[{0}\\]] #link("{1}")[{2}]], qrcode("{1}"), \n'.format(
        i + 1,
        link.location.replace(/\\/g, '\\\\'),
        link.children)
    }
    article += ')\n'
  }

  return article

  // Primary functions
  function parseDefinition(tree) {
    visit(tree, 'footnoteDefinition', node => {
      mapFootnoteDefinitions.set(node.identifier, node)
    })

    visit(tree, 'definition', node => {
      mapDefinitions.set(node.identifier, node)
    })
  }

  function parse(node) {
    const makeLink = function (url) {
      const children = all(node, parse).join('')

      if (isInternalLink(url)) {
        const location = toPrefix(joinRelative(url, options))
        return (location !== '' && children !== '') ? `@${location}` : ''
      } else {
        ++linkIndex
        const location = url.replace(/\\/g, '\\\\')
        arrayLinks.push({ location: location, children: children })
        return '#link("{0}")[{1}]#super(text(fill: cmyk(0%, 100%, 100%, 0%))[\\[{2}\\]])'.format(location, children, linkIndex)
      }
    }

    // 插入图片，若是网络资源则先下载到本地再插入
    const makeImage = function (loc) {
      // NOTE: hugh, why should we copy all files into here,
      // while we can actually visit them in-place?
      let uri = joinRelative(node.url, options)
      try {
        let ext = ''
        let dest = ''
        if (isUrl(loc)) {
          const url = new URL(loc)
          ext = extname(url.pathname)
          dest = join('images', toPrefix(join(dirname(uri), basename(url.pathname, ext))) + ext)
          // download
          if (!existsSync(dest)) {
            const body = request('GET', loc).getBody()
            writeFileSync(dest, body)
          }
          uri = dest
        } else {
          ext = extname(loc)
        }
        const is_svg = ext === '.svg'
        dest = join('images', toPrefix(join(dirname(uri), basename(uri, extname(uri)))) + (is_svg ? '.svg' : '.jpg'))
        // convert
        switch (ext) {
          case '.jpg':
          case '.svg': {
            if (!existsSync(dest)) {
              copyFileSync(uri, dest)
            }
            break
          }
          case '.jpeg': {
            if (!existsSync(dest)) {
              copyFileSync(uri, basename(dest, 'jpeg') + '.jpg')
            }
            break
          }
          default: {
            if (!existsSync(dest)) {
              // 混合白色背景（原图可能是 PNG 透明图）
              execFileSync('convert', ['-background', 'white', '-flatten', ext === '.gif' ? uri + '[0]' : uri, dest])
            }
            break
          }
        }
        return '#figauto(src: "./images/{0}", alt: "{1}")\n'.format(basename(dest), node.alt || '')
      } catch (e) {
        console.error('[ERROR] Error occurred when processing image file `{0}`'.format(uri))
        return ''
      }
    }

    // 节点匹配逻辑
    switch (node.type) {
      case 'root': {
        const article = trailingLineFeed(all(node, parse).join('\n'))
        return article
      }
      case 'paragraph': {
        const parText = all(node, parse).join('')

        if (parText.startsWith('author: ')) {
          return '#authors[{0}]'.format(parText.slice(8))
        }
        if (parText.startsWith('disqus:')) {
          return ''
        }
        if (firstPar) {
          firstPar = false
          return '#par[#h(2em){0}]\n'.format(parText)
        } else {
          return '#par[{0}]\n'.format(parText)
        }
      }
      case 'heading': {
        const depth = Math.min(options.depth + (node.depth - 1), 6)
        return '#heading(level: {0}, numbering: none, outlined: false)[{1}]'.format(
          depth, 
          all(node, parse).join(''),
          options.nested ? '' : options.prefix)
      }
      case 'text': {
        // NOTE: remove spaces between text objects
        // since this is not a common practice in east asian typesetting.
        let text = node.value

        if (options.forceLinebreak) {
          text = forceLinebreak(text)
        }

        if (isEscapingAsString) {
          text = escapeAsString(text)
        } else {
          text = escape(text)
        }

        return text
      }
      case 'emphasis': {
        return '#emph[{0}]'.format(all(node, parse).join(''))
      }
      case 'strong': {
        return '#strong[{0}]'.format(all(node, parse).join(''))
      }
      case 'inlineCode': {
        return '#raw("{0}", block: false)'.format(escapeAsString(node.value))
      }
      case 'code': {
        const content = '#codeblock(lang: "{1}", unwrapped: {2}, "{0}")\n'.format(
          escapeAsString(node.value) || '',
          getLanguage(node.lang),
          unwrap
        )
        unwrap = false

        return content
      }
      case 'delete': {
        return '#strike[{0}]'.format(all(node, parse).join(''))
      }
      case 'list': {
        const base = node.ordered
          ? '#enum(start: {0})'.format(node.start)
          : '#list'
        return base + all(node, parse).map(s => '[{0}]'.format(s)).join('') + '\n'
      }
      case 'listItem': {
        return all(node, parse).join('')
      }
      case 'thematicBreak': { // 水平分割线
        return '#horizontalrule\n' // 在印刷物中使用水平分割线也许不是好的实践
      }
      case 'blockquote': {
        return '#blockquote[{0}]\n'.format(all(node, parse).join(''))
      }
      case 'break': {
        return '#parbreak()'
      }
      case 'yaml': {
        return '' // YAML front-matter，这里直接忽略
      }
      case 'html': { // HTML 标签（不含标签里的内容）
        if (node.value === '<kbd>') {
          isEscapingAsString = true
          return '#kbd("'
        } else if (node.value === '</kbd>') {
          isEscapingAsString = false
          return '")'
        } else {
          return ''
        }
      }
      case 'link': {
        return makeLink(node.url)
      }
      case 'linkReference': {
        if (mapDefinitions.get(node.identifier)) {
          return makeLink(mapDefinitions.get(node.identifier).url)
        }
        return ''
      }
      case 'image': {
        return makeImage(node.url.toLowerCase())
      }
      case 'imageReference': {
        if (mapDefinitions.get(node.identifier)) {
          return makeImage(mapDefinitions.get(node.identifier).url)
        }
        return ''
      }
      case 'table': {
        // 如果表格有多余列（相对表头）则去掉
        node.children.map(child => {
          child.children = child.children.slice(0, node.align.length)
        })
        // 用 tablex 插件创建可自动适应比例、可自动分页的长表格
        // TODO: repeat-header
        return `
#align(center, tablex(
columns: {0},
align: (col, row) => ({1}).at(col),
stroke: antiflash-white.dark,
auto-lines: false,
auto-hlines: true,
vlinex(),
{2}
{3}
vlinex(),
))
`.format(node.align.length,
          node.align.map(s => s || 'center').join(','),
          parse(node.children[0]),
          node.children.slice(1).map(parse).join(''))
      }
      case 'tableRow': {
        return all(node, parse).join(', ') + ',\n'
      }
      case 'tableCell': {
        return '[{0}]'.format(all(node, parse).join(''))
      }
      case 'footnote': {
        hasFootnotes = true
        return '#footnote[{0}]'.format(all(node, parse).join(''))
      }
      case 'footnoteReference': {
        hasFootnotes = true
        return '#footnote[{0}]'.format(
        all(mapFootnoteDefinitions.get(node.identifier), parse).join(''))
      }
      case 'definition': {
        return '' // 已经预处理掉了
      }
      case 'footnoteDefinition': {
        return '' // 已经预处理掉了
      }
      case 'inlineMath': { // 行内公式
        const texmath = spawnSync(
          'texmath-arg',
          ['-f', 'tex', '-t', 'typst', '--inline', '--', node.value]
        )

        if (texmath.status === 1) {
          const err = texmath.stderr.toString('utf8')
          console.log('[WARN] Problem converting inline math. Falling back to SVG:\n' + err)

          renderSvg({}, {}).render(node, {})
          return '#inlinemath(svg: "{0}")'.format(node.value.replace(/\"/g, '\\\"'))
        }

        return ` $${texmath.stdout.toString('utf8').trimEnd()}$ `
      }
      case 'math': { // 行间公式
        const texmath = spawnSync(
           'texmath-arg',
           ['-f', 'tex', '-t', 'typst', '--', node.value]
        )

        if (texmath.status === 1) {
          const err = texmath.stderr.toString('utf8')
          console.log('[WARN] Problem converting display math. Falling back to SVG:\n' + err)

          renderSvg({}, {}).render(node, {})
          return '#dispmath(svg: "{0}")'.format(node.value.replace(/\"/g, '\\\"'))
        }

        return `$ ${texmath.stdout.toString('utf8').trimEnd()} $`
      }
      case 'detailsContainer': { // Pymdown details 语法块
        const type = node.attributes.class
        const summary = parse(node.children[0])

        unwrap = node.children && (node.children.length === 2) && (node.children[1].type === 'code')
        node.children = node.children.slice(1)

        if (type) {
          return '#details(type: "{0}", unwrap: {1})[{2}][{3}]'.format(
            type,
            unwrap,
            removeQuotes(summary),
            all(node, parse).join('')
          )
        } else {
          const isTrivial = DETAILS_TYPES.includes(summary)
          if (isTrivial) {
            return '#details(type: "{0}", unwrap: {1})[{2}][{3}]'.format(
              summary, 
              unwrap,
              capitalize(summary),
              all(node, parse).join('')
            )
          } else {
            return '#details(type: "note", unwrap: {0})[{1}][{2}]'.format(
              unwrap,
              removeQuotes(summary),
              all(node, parse).join('')
            )
          }
        }
      }
      case 'detailsContainerSummary': {
        return '{0}'.format(all(node, parse).join(''))
      }
      default: {
        console.error('[ERROR] Unsupported node type: {0}'.format(node.type))
        console.error(JSON.stringify(node, null, '\t'))
        return ''
      }
    }
  }
}