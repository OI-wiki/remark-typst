'use strict'

const visit = require('unist-util-visit')
const path = require('path')
const util = require('./util')
const child_process = require('child_process')
const fs = require('fs')
const unified = require('unified')
const rparse = require('remark-parse')
const math = require('remark-math')
const details = require('remark-details')
const footnotes = require('remark-footnotes')
const request = require('sync-request')
const URL = require('url').URL
// Escape Typst's reserved symbols
const escape = require('../escape-typst/src/index')
// MathJax SVG export
const renderSvg = require('../remark-mathjax/svg').renderSvg

// 给 String 添加 format 方法，方便格式化输出
if (!String.prototype.format) {
  String.prototype.format = function () {
    const args = arguments
    return this.replace(/{(\d+)}/g, (match, number) => {
      return typeof args[number] !== 'undefined' ? args[number] : match
    })
  }
}

module.exports = compiler

function compiler(options) {
  // const outLinkLabel = new Map() // 所有的外部链接，包括直接链接和引用式链接，键-值：链接-链接label
  // let hasFootnote = false // 判断之前有没有footnote
  // let outLinkBeginCount = 0
  // const links = {} // 引用式链接，键-值：标识符-链接地址
  // const footnote = {} // 引用式脚注，键-值：序号（1 起始）-脚注内容
  // const qrCode = {} // 脚注的二维码
  // const indices = {} // 脚注序号，键-值：标识符-脚注序号
  // const identifiers = {} // indices 的逆映射
  // const footnoteRefs = {} // 脚注被引用的次数，键-值：标识符-引用次数
  // const footnoteRefId = {} // 脚注当前被引用第几次，键-值：脚注序号-第几次引用

  // let footnoteCount = 0 // 脚注数量
  // let inFootnote = false

  // Footnote: Node
  const mapFootnotes = new Map()
  // Definition: Node
  const mapDefinitions = new Map()
  // Link: { location: string, children: content }
  const arrayLinks = new Array()

  // Index of current foreign link
  let linkIndex = 0
  // Whether footnotes are used, which suggests that a section
  // named "References" is present in original markdown document
  let hasFootnotes = false
  // Whether the current details block should be unwrapped
  let unwrap = false
  // Whether the current paragraph should be indented
  let firstPar = true
  // Whether the current text node should be escaped
  let isEscapingForString = false

  parser.prototype.compile = wrapper
  return parser

  function parser(tree, file) {
    this.tree = tree
    this.file = file
  }

  function wrapper() {
    // 处理掉所有标签定义和链接跳转定义
    parseDefinition(this.tree)
    // 解析文章
    let article = `// Generated by remark-typst
#import "@preview/tablex:0.0.5": *
#import "../oi-wiki.typ": *
`
    article += parse(this.tree)
    // 创建文章尾注，对外链添加二维码
    if (linkIndex > 0) {
      if (hasFootnotes === false) {
        article += '#heading(level: {0}, numbering: none, outlined: false)[参考资料与注释]\n'.format(
          options.depth + 1)
      }

      article += '#links-grid('
      for (const [i, link] of arrayLinks.entries()) {
        article += 'links-cell[#text(fill: cmyk(0%, 100%, 100%, 0%))[\\[{0}\\]] #link("{1}")[{2}]], qrcode("{1}"), '.format(
          i + 1,
          link.location.replace(/\\/g, '\\\\'),
          link.children)
      }
      article += ')\n'
    }

    // if (footnoteCount > 0) {
    //   if (hasFootnote === false) {
    //     article += '\n==== 参考资料与注释'
    //   }
    //   article += '\n\\begin{enumerate}\n'
    //   for (let id = 1; id <= footnoteCount; ++id) {
    //     const fullLabel = options.prefix + identifiers[id]
    //     if (footnoteRefs[identifiers[id]] === 1) {
    //       article += `\\renewcommand{\\labelenumi}{\\hyperref[endnoteref:${fullLabel}-1]{[\\theenumi]}}\n`
    //     } else {
    //       article += '\\renewcommand{\\labelenumi}{[\\theenumi]}\n'
    //     }
    //     article += '\\item\\label{endnote:{0}}'.format(fullLabel) + footnote[id]
    //     if (footnoteRefs[identifiers[id]] >= 2) {
    //       for (let cnt = 1; cnt <= footnoteRefs[identifiers[id]]; ++cnt) {
    //         article += ` \\hyperref[endnoteref:${fullLabel}-${cnt}]{[${id}-${cnt}]}`
    //       }
    //     }
    //     article += '#h(1fr)' // align qrcode to right
    //     // 为尾注增添二维码
    //     const url = getUrlFromFootnote(id)
    //     for (let i = 0; i < url.length; i++) {
    //       url[i] = url[i].replace('\\textasciitilde{}', '~')
    //       // ban cjk urls, due to the fact that they are not supported by latex qrcode
    //       if (url[i].split('').map(c => util.isCjk(c)).filter(c => c).length > 0) {
    //         url[i] = encodeURI(url[i])
    //       }
    //       const urlFormat = `\\quad \\qrcode[height=1cm]{${url[i]}}`
    //       article += urlFormat
    //     }
    //     article += '\n'
    //   }
    //   article += '\\end{enumerate}\n'
    // }
    return article
  }

  // function getUrlFromFootnote(id) {
  //   const regexp = /\\hyref\{.*?\}\{.*?\}/g
  //   const footnoteTmp = footnote[id]
  //   const array = [...footnoteTmp.matchAll(regexp)]
  //   const url = []
  //   for (let i = 0; i < array.length; i++) {
  //     const subArray = String(array[i]).split('hyref')
  //     // 括号匹配
  //     let leftCnt = 0; let rightCnt = 0
  //     let position = -1
  //     for (let j = 0; j < subArray[1].length; j++) {
  //       if (subArray[1][j] === '{') leftCnt++
  //       if (subArray[1][j] === '}') rightCnt++
  //       if (leftCnt !== 0 && leftCnt === rightCnt) {
  //         position = j
  //         break
  //       }
  //     }
  //     url[i] = subArray[1].slice(1, position)
  //   }
  //   return url
  // }

  function parseDefinition(tree) {
    visit(tree, 'footnoteDefinition', node => {
      mapFootnotes.set(node.identifier, node)
    })

    // visit(tree, 'footnoteReference', function (node) {
    //   ++footnoteRefs[node.identifier]
    // })

    visit(tree, 'definition', node => {
      // if (outLinkBeginCount === 0) {
      //   outLinkBeginCount = footnoteCount + 1
      // }
      mapDefinitions.set(node.identifier, node)
    })

    // visit(tree, 'link', function (node) {
    //   if (outLinkBeginCount === 0) {
    //     outLinkBeginCount = footnoteCount + 1
    //   }
    //   const location = escape(node.url)
    //   if (util.isInternalLink(node.url) === false && outLinkLabel.has(location) === false) {
    //     ++footnoteCount
    //     outLinkLabel.set(location, 'OutLink_{0}'.format(footnoteCount))
    //     indices[outLinkLabel.get(location)] = footnoteCount
    //     identifiers[footnoteCount] = outLinkLabel.get(location)
    //     footnoteRefId[footnoteCount] = 0
    //     footnoteRefs[outLinkLabel.get(location)] = 0
    //     const children = util.all(node, parse).join('')
    //     footnote[footnoteCount] = '#link("{0}")[{1}]'.format(location, children)
    //   }
    //   footnoteRefs[outLinkLabel.get(location)]++
    // })
  }

  function parse(node) {
    const makeLink = function (url) {
      const raw = util.all(node, parse).join('')

      // const prevForce = options.forceLinebreak
      // options.forceLinebreak = true
      const children = util.all(node, parse).join('')
      // options.forceLinebreak = prevForce

      if (util.isInternalLink(url)) {
        const location = util.toPrefix(util.joinRelative(url, options))
        return (location !== '' && raw !== '') ? '@{0}'.format(location, children) : ''
      } else {
        const location = url.replace(/\\/g, '\\\\')
        ++linkIndex
        arrayLinks.push({ location: location, children: children })
        // if (outLinkLabel.has(location) === false || inFootnote) {
        //   if (location === raw) {
        //     return '#link("{0}")[{1}]'.format(location, children)
        //   } else {
        //     return (location !== '' && raw !== '') ? '#link("{0}")[{1}]'.format(location, children) : ''
        //   }
        // }
        // const label = outLinkLabel.get(location)
        // const index = indices[label]
        // ++footnoteRefId[index]
        // if (location === raw) {
        return '#link("{0}")[{1}]#super(text(fill: cmyk(0%, 100%, 100%, 0%))[\\[{2}\\]])'.format(location, children, linkIndex)
        // } else {
        //   return (location !== '' && raw !== '') ? '#link("{0}")[{1}]'.format(location, children) + '#footnote[{0}]'.format(escape(location)) : ''
        // }
      }
    }

    // 插入图片，若是网络资源则先下载到本地再插入
    const makeImage = function (loc) {
      // NOTE: hugh, why should we copy all files into here,
      // while we can actually visit them in-place?
      let uri = util.joinRelative(node.url, options)
      try {
        let ext = ''
        let dest = ''
        if (util.isUrl(loc)) {
          const url = new URL(loc)
          ext = path.extname(url.pathname)
          dest = path.join('images', util.toPrefix(path.join(path.dirname(uri), path.basename(url.pathname, ext))) + ext)
          // download
          if (!fs.existsSync(dest)) {
            const body = request('GET', loc).getBody()
            fs.writeFileSync(dest, body)
          }
          uri = dest
        } else {
          ext = path.extname(loc)
        }
        const is_svg = ext === '.svg'
        dest = path.join('images', util.toPrefix(path.join(path.dirname(uri), path.basename(uri, path.extname(uri)))) + (is_svg ? '.svg' : '.jpg'))
        // convert
        switch (ext) {
          case '.jpg':
          case '.svg': {
            if (!fs.existsSync(dest)) {
              fs.copyFileSync(uri, dest)
            }
            break
          }
          case '.jpeg': {
            if (!fs.existsSync(dest)) {
              fs.copyFileSync(uri, path.basename(dest, 'jpeg') + '.jpg')
            }
            break
          }
          default: {
            if (!fs.existsSync(dest)) {
              // 混合白色背景（原图可能是 PNG 透明图）
              child_process.execFileSync('convert', ['-background', 'white', '-flatten', ext === '.gif' ? uri + '[0]' : uri, dest])
            }
            break
          }
        }
        return '#figauto(src: "./images/{0}", alt: "{1}")\n'.format(path.basename(dest), node.alt || '')
      } catch (e) {
        console.error('[ERROR] Error occurred when processing image file `{0}`'.format(uri))
        return ''
      }
    }

    // 节点匹配逻辑
    switch (node.type) {
      case 'root': {
        const article = util.trailingLineFeed(util.all(node, parse).join('\n'))
        return article
      }
      case 'paragraph': {
        const parText = util.all(node, parse).join('')

        if (parText.startsWith('author: ')) {
          return '#authors[{0}]'.format(parText.slice(8))
        }
        if (parText.startsWith('disqus:')) {
          return ''
        }
        if (firstPar) {
          firstPar = false
          return '#par[#h(2em){0}]\n'.format(parText)
        } else {
          return '#par[{0}]\n'.format(parText)
        }
      }
      case 'heading': {
        const depth = Math.min(options.depth + (node.depth - 1), 6)
        
        return depth <= 3
             ? '#heading(level: {0}, outlined: false)[{1}]'.format(
              depth, 
              util.all(node, parse).join(''),
              options.nested ? '' : options.prefix)
             : '#heading(level: {0}, numbering: none, outlined: false)[{1}]'.format(
              depth, 
              util.all(node, parse).join(''),
              options.nested ? '' : options.prefix)
      }
      case 'text': {
        // NOTE: remove spaces between text objects
        // since this is not a common practice in east asian typesetting.
        let text = node.value

        if (options.forceLinebreak) {
          text = util.forceLinebreak(text)
        }

        if (isEscapingForString) {
          text = util.escapeForString(text)
        } else {
          text = escape(text)
        }

        return text
      }
      case 'emphasis': {
        return '#emph[{0}]'.format(util.all(node, parse).join(''))
      }
      case 'strong': {
        return '#strong[{0}]'.format(util.all(node, parse).join(''))
      }
      case 'inlineCode': {
        return '#raw("{0}", block: false)'.format(util.escapeForString(node.value))
      }
      case 'code': {
        const content = '#codeblock(lang: "{1}", unwrapped: {2}, "{0}")\n'.format(
          util.escapeForString(node.value) || '',
          util.getLanguage(node.lang),
          unwrap
        )
        unwrap = false

        return content
      }
      case 'delete': {
        return '#strike[{0}]'.format(util.all(node, parse).join(''))
      }
      case 'list': {
        const base = node.ordered
          ? '#enum(start: {0})'.format(node.start)
          : '#list'
        return base + util.all(node, parse).map(s => '[{0}]'.format(s)).join('') + '\n'
      }
      case 'listItem': {
        return util.all(node, parse).join('')
      }
      case 'thematicBreak': { // 水平分割线
        return '#horizontalrule\n' // 在印刷物中使用水平分割线也许不是好的实践
      }
      case 'blockquote': {
        return '#blockquote[{0}]\n'.format(util.all(node, parse).join(''))
      }
      case 'break': {
        return '#parbreak()'
      }
      case 'yaml': {
        return '' // YAML front-matter，这里直接忽略
      }
      case 'html': { // HTML 标签（不含标签里的内容）
        if (node.value === '<kbd>') {
          isEscapingForString = true

          return ' #kbd("'
        } else if (node.value === '</kbd>') {
          isEscapingForString = false

          return '") '
        } else {
          return ''
        }
      }
      case 'link': {
        return makeLink(node.url)
      }
      case 'linkReference': {
        if (mapDefinitions.get(node.identifier)) {
          return makeLink(mapDefinitions.get(node.identifier).url)
        }
        return ''
      }
      case 'image': {
        return makeImage(node.url.toLowerCase())
      }
      case 'imageReference': {
        if (mapDefinitions.get(node.identifier)) {
          return makeImage(mapDefinitions.get(node.identifier).url)
        }
        return ''
      }
      case 'table': {
        // 如果表格有多余列（相对表头）则去掉
        node.children.map(child => {
          child.children = child.children.slice(0, node.align.length)
        })
        // 用 tablex 插件创建可自动适应比例、可自动分页的长表格
        // TODO: repeat-header
        return `
#tablex(
columns: {0},
align: (col, row) => ({1}).at(col),
stroke: antiflash-white.dark,
auto-lines: false,
auto-hlines: true,
vlinex(),
{2}
{3}
vlinex(),
)
`.format(node.align.length,
          node.align.map(s => s || 'center').join(','),
          parse(node.children[0]),
          node.children.slice(1).map(parse).join(''))
      }
      case 'tableRow': {
        return util.all(node, parse).join(', ') + ',\n'
      }
      case 'tableCell': {
        return '[{0}]'.format(util.all(node, parse).join(''))
      }
      case 'footnote': {
        hasFootnotes = true
        return '#footnote[{0}]'.format(util.all(node, parse).join(''))
      }
      case 'footnoteReference': {
        hasFootnotes = true
        // const index = indices[node.identifier]
        // ++footnoteRefId[index]
        return '#footnote[{0}]'.format(
        // util.nonParagraphBegin(util.all(_footnotes.get(node.identifier), parse).join('')))
        util.all(mapFootnotes.get(node.identifier), parse).join(''))
      }
      case 'definition': {
        return '' // 已经预处理掉了
      }
      case 'footnoteDefinition': {
        return '' // 已经预处理掉了
      }
      case 'inlineMath': { // 行内公式
        const texmath = child_process.spawnSync(
          'texmath-arg',
          ['-f', 'tex', '-t', 'typst', '--inline', '--', node.value]
        )

        if (texmath.status === 1) {
          const err = texmath.stderr.toString('utf8')
          console.log('[WARN] Problem converting inline math. Falling back to SVG:\n' + err)

          renderSvg({}, {}).render(node, {})
          return '#inlinemath(svg: "{0}")'.format(node.value.replace(/\"/g, '\\\"'))
        }

        return ` $${texmath.stdout.toString('utf8').trimEnd()}$ `
      }
      case 'math': { // 行间公式
        const texmath = child_process.spawnSync(
          'texmath-arg',
          ['-f', 'tex', '-t', 'typst', '--', node.value]
        )

        if (texmath.status === 1) {
          const err = texmath.stderr.toString('utf8')
          console.log('[WARN] Problem converting display math. Falling back to SVG:\n' + err)

          renderSvg({}, {}).render(node, {})
          return '#dispmath(svg: "{0}")'.format(node.value.replace(/\"/g, '\\\"'))
        }

        return `$ ${texmath.stdout.toString('utf8').trimEnd()} $`
      }
      case 'details': { // Pymdown details 语法块
        const [defaultTitle, color] =
            (node.value === 'warning') ? ['Warning', 'warning-orange']
          : (node.value === 'tip')     ? ['Tip',     'tip-green']
          :                              ['Note',    'note-blue']

        const prevNested = options.nested
        options.nested = true
        let tree = unified()
          .use(rparse)
          .use(math)
          .use(details)
          .use(footnotes)
          .parse(node.title || defaultTitle)
        // let title = util.nonParagraphBegin(util.all(tree, parse).join(''))
        let title = util.all(tree, parse).join('')
        options.nested = prevNested

        unwrap = node.children && (node.children.length == 1) && (node.children[0].type == 'code')
        return '#details(unwrap: {0}, type: "{1}", color: {2})[{3}][{4}]\n'.format(
          unwrap,
          node.value,
          color,
          title,
          util.all(node, parse).join(''))
      }
      default: {
        console.error('[ERROR] Unsupported node type: {0}'.format(node.type))
        console.error(JSON.stringify(node, null, '\t'))
        return ''
      }
    }
  }
}
